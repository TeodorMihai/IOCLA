
import os
import re
import subprocess
import sys

if sys.platform.startswith("win"):
	# Don't display the Windows GPF dialog if the invoked program dies.
	# See comp.os.ms-windows.programmer.win32
	#  How to suppress crash notification dialog?, Jan 14,2004 -
	#     Raymond Chen's response [1]

	import ctypes
	SEM_NOGPFAULTERRORBOX = 0x0002 # From MSDN
	ctypes.windll.kernel32.SetErrorMode(SEM_NOGPFAULTERRORBOX);
	CREATE_NO_WINDOW = 0x08000000    # From Windows API
	subprocess_flags = CREATE_NO_WINDOW
else:
	subprocess_flags = 0

sourceName = 'tema3.c'
execName   = 'tema3.exe'

credentialsFile = 'credentials.txt'

os.environ["PATH"] = 'C:\\Python27\\;C:\\MinGW\\bin\\;' + os.environ["PATH"]

compilerPath = 'C:\\MinGW\\bin\\gcc'
comilerArguments = compilerPath + ' ' + sourceName + ' -o ' + execName

score = 0
totalScore = 30

def read_credentials():
    global nume, prenume, grupa
    with open(credentialsFile) as f:
        nume, prenume, grupa = f.read().splitlines()

def generate():
    generateCommand = 'C:\\Python27\\python mangler.py %s %s %s' % (nume, prenume, grupa)
    r = subprocess.call(generateCommand)
    if r != 0:
        return False
    return True

def build():
    r = subprocess.call(comilerArguments)
    if r != 0:
        return False
    return True

def passed(task):
    global score
    score += 10
    t = 'Task 3' + task
    m = 'PASSED'
    print(t + (60 - len(t + m)) * '.' + m)
    return True

def failed(task):
    t = 'Task 3' + task
    m = 'FAILED'
    print(t + (60 - len(t + m)) * '.' + m)
    return False

def get_payload(task):
    fname = 'payload_' + task
    payload = ''
    if os.path.isfile(fname):
        with open(fname) as f:
            payload = f.read()

    return payload

# generic function for the first two tasks (a, b)
def check_ab(task, expected):
    payload = get_payload(task)
    if not payload:
        return failed(task)

    p = subprocess.Popen(execName, stdin=subprocess.PIPE, stdout=subprocess.PIPE, creationflags=subprocess_flags)
    (output, _) = p.communicate(payload)

    if re.search(expected, output):
        return passed(task)
    else:
        return failed(task)

def check_a():
    return check_ab('a', 'Well done!')

def check_b():
    return check_ab('b', 'Well done again!')

def check_c():
    payload = get_payload(task='c')
    if not payload:
        return failed(task='c')

    p = subprocess.Popen(execName, stdin=subprocess.PIPE, stdout=subprocess.PIPE)
    p.communicate(payload)

    if os.path.isfile(prenume):
        return passed('c')
    else:
        return failed('c')

def check_all():
    check_a()
    check_b()
    check_c()

def clean():
	if os.path.isfile(execName):
		os.remove(execName)
	if os.path.isfile(prenume):
		os.remove(prenume)

if __name__ == '__main__':

    read_credentials()
    if not generate():
        failed('a')
        failed('b')
        failed('c')
        sys.exit(1)
    if not build():
        failed('a')
        failed('b')
        failed('c')
        sys.exit(1)

    check_all()

    s = '%d/%d' % (score, totalScore)
    r = 'Result: '
    print((60 - len(r + s)) * ' ' + r + s)

    clean()
